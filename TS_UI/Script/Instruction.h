//#####################################
//
//	class CInstruction
//
//	指令类（各芯片类的基类，形成统一对外接口）
//
//	仅构建指令，与脚本无关
//
//	最后修改日期：2015-11-13 11:37
//#####################################

#ifndef INSTRUCTION_H
#define INSTRUCTION_H

#include "Information.h"
#include "Parameter.h"
#include <string>
#include <sstream>
using namespace std;

//指令样式
#define STYLE_SEPARATOR	0x08	//指令头部与数据域内容间添加空格，如“00A4020002 EF05”
#define STYLE_INSTHEAD	0x04	//指令头部每字节间添加空格，如“00 84 00 00 08”，注如果与STYLE_SEPARATOR一起使用，指令头部与数据域间将会变作两个空格，如“00 A4 02 00 02  EF05”
#define STYLE_INSTDATA	0x02	//在数据域内容中添加恰当的空格（各函数有差异），只有在传入的数据域内容中不含任何常量及变量信息时才生效

//EF 文件类型
#define EFTYPE_FIXED_LENGTH		"1"		//定长文件
#define EFTYPE_VARIABLE_LENGTH	"2"		//变长文件
#define EFTYPE_BINARY			"3"		//二进制文件
#define EFTYPE_LOOP				"4"		//循环文件
#define EFTYPE_INTERNAL			"5"		//内部文件

//记录的数据格式
#define RECORD_AN		"an"		//	AN格式
#define RECORD_CN		"cn"		//	CN格式
#define RECORD_B		"b"			//	B格式
#define RECORD_TLV		"B-TLV"		//	B-TLV格式
#define RECORD_LOOP		"-"			//	循环记录



class CInstruction
{
public:
	CInstruction( CInformation *inf, CParameter *para );
	virtual ~CInstruction();
		/**************************************
		功能：重设错误标志
		描述：
		在构建指令的过程中，只要发生了错误，内部错误标志就会被标志为"true"；
		使用该方法可以将错误标志重设为"false"，与方法 Error() 结合使用。
		**************************************/
	void ReSetErrFlag();
		/**************************************
		功能：判断错误
		返回：
		true：发生错误
		false：并没有错误
		描述：
		在构建指令的过程中，只要发生了错误，内部错误标志就会被标志为"true"；
		在使用方法 ReSetErrFlag() 将内部错误标志置为"false"之后，可使用该方法来获取错误标志，用以判断所构建的一条或多条连续的指令是否正确。
		**************************************/
	bool Error();//判断错误
		/**************************************
		功能：打开或关闭参数检查
		参数：
		IN：Swf：当该值为true时，每构建一条指令前都会对各参数进行相应的检查，如果该值为false，则忽略参数的检查
		描述：
		在class CInstruction实例化时默认打开构建指令时的参数检查，参数检查会消耗一定的执行时间，如确保参数无误，可将其关闭
		**************************************/
	void Error_Check(bool Swf);//是否打开错误检查
		/**************************************
		功能：设置生成脚本命令的样式
		参数（可有以下一个或多个宏定义按位求或来拼接组成）：
		STYLE_SEPARATOR：指令头部与数据域内容间添加空格，如“00A4020002 EF05”
		STYLE_INSTHEAD：指令头部每字节间添加空格，如“00 84 00 00 08”，注如果与STYLE_SEPARATOR一起使用，指令头部与数据域间将会变作两个空格，如“00 A4 02 00 02  EF05”
		STYLE_INSTDATA：在数据域内容中添加恰当的空格（各函数有差异），只有在传入的数据域内容中不含任何常量及变量信息时才生效
		描述：
		可通过该设置项来更变所生成脚本的样式，如果要取消所有样式的设置请输入“0”
		注意：
		通过 Get_Instruction_Head 和 Get_Instruction_Data 来获取的数据将不受样式影响。
		如果不设置 STYLE_INSTDATA 项，所传入的数据域内容将保留原本格式。
		**************************************/
	void Style_Set(unsigned char Sty);//设置样式
		/**************************************
		功能：取出指令头部
		返回：将返回指令的头部，通过此方法来获取的指令头部，将不受Style_Set的样式影响
		注意：如果指令的头部并未构建成功，将会返回一个长度为0的字符串，请在确认指令方法执行成功后再获取指令头部。
		**************************************/
	string Get_Instruction_Head();
		/**************************************
		功能：取出指令附加数据
		返回：将返回指令的附加数据，通过此方法来获取的数据，将不受Style_Set的样式影响
		描述：
		一般而言，执行一个指令方法只会构建指令的头部，此项附加数据一般保持为空；
		但某些指令会在该附加数据中输出一下额外的内容，具体请留意其指令方法的描述信息。
		**************************************/
	string Get_Instruction_Data();
		/**************************************
		功能：设置扩展参数
		注意：
		每个参数以“|”作为结尾，如“170|”、“0|10|”，各参数含义参见对应指令方法的描述信息
		描述：
		在Instruction类中为每一种芯片的指令方法都定义了统一的参数列表，
		有可能会出现某个芯片要求的参数超出了参数列表的范围，此时需要使用该扩展参数来传递额外的数据。
		设计：
		如果当前已经规范好的接口无法满足日后某些COS指令的参数要求，则可通过此扩展参数进行传递。
		**************************************/
	void Extend_Param(string Ext);
		/**************************************
		功能：获取指定内部文件的FID
		参数：
		IN：FType：所创建内部文件的类型，仅可取值为"SF"、"FCI"、"DIR"、"TF"、"ATR"
		注意：
		该方法仅在生成建卡脚本时有效，只能获取待建立内部文件的FID
		**************************************/
	string Get_Internal_FID(string FType);


		/**************************************
		功能：生成随机数
		参数：
		IN：Len：指定需生成随机数的长度，该值只能是“4”、“8”或“16”（十进制）
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		**************************************/
	virtual string Get_Challenge(int Len, bool RefreshFlag = true);
		/**************************************
		功能：选择文件
		参数：
		IN：Dir：标志着所需选择的文件是否为目录文件（MF、DDF、ADF），true为目录文件，false为EF文件
		IN：FID：标志着是否使用FID的形式来选择文件，true为使用FID形式，false为使用AID形式
		IN：Len：所需选择文件的FID或AID的字节长度，如使用FID形式，该值应固定为“2”
		IN：Data：文件的FID或AID，可以是符合变量（如：“[VAR10]”）或常量名称（如：“[CON10]”）的字符串
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		0：执行成功
		!0：发生错误，InstHead与InstData将保持为空
		注意：
		FID：文件标识符，固定为两字节长度，如"3F00"、"DF01"、"EF05"等
		AID：应用标识符，如"7378312E73682EC9E7BBE1B1A3D5CF"等
		**************************************/
	virtual string Select_File(bool Dir, bool FID, int Len, string Data, bool RefreshFlag = true);
		/**************************************
		功能：选择文件
		参数：（该方法将会自行获取所需配置参数）
		IN：MF：根目录，可以取值为"MF"、文件标志符（如"3F00"）或保留为空""，当为空时将默认为"MF"
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）、文件标志符（如"DDF1"、"DDF2"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：EF：基本文件，可以取值为文件标识符（如"EF05"、"EF06"等）或保留位空""，当为空时将表示并非选择基本文件
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		描述：
		MF、DDF、ADF和EF四个入参，将根据最后一个非空的参数来确定将构建的指令是选择哪一级别的目录或文件；
		如入参（"MF", "SSSE", "", "EF05"）将表示选择SSSE下的EF05，入参（"MF", "SSSE", "", ""）将表示选择SSSE；
		注意：
		对于DDF、ADF文件将采用文件名的方式来进行构建(如"7378312E73682EC9E7BBE1B1A3D5CF")，对于MF和EF文件将采用文件标识符的方式来进行构建（如"3F00"、"EF05"）。
		**************************************/
	virtual string Select_File(string MF = "", string DDF = "", string ADF = "", string EF = "", bool RefreshFlag = true);
		/**************************************
		功能：外部认证
		参数：
		IN：KeyID：需认证的密钥标识，要求必须由两位字符组成，如"04"、"0A"、"83"、"8B"等
		IN：Cipher：鉴别数据，需认证密钥的过程密钥对 Scr 加密后的密文，可以是符合变量名称的字符串（如：“[VAR10]”）
		IN：Scr：鉴别所需原始信息，可以是符合变量名称的字符串（如：“[VAR10]”）
		IN：KeyVer：密钥版本，取值范围为0-3，其中1-3分别表示需认证的版本，默认值为0表示不附加任何版本信息
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		注意：
		对脚本来说，将会有专门的外部认证语句，除非使用固定密钥，否则该方法估计不会被派上用场；
		对于某些COS可能参数 Scr 并不存在（如：0082000008 XXXXXXXXXXXXXXXX），则对 Scr 传入空串则可
		**************************************/
	virtual string External_Authenticate(string KeyID, string Cipher, string Scr, int KeyVer = 0, bool RefreshFlag = true);
		/**************************************
		功能：修改记录
		参数：
		IN：P1：记录号或记录标识符，要求必须由两位字符组成，如"01"、"02"、"4E"等
		IN：P2：控制参数2，具体含义请参见各COS手册，要求必须由两位字符组成
		IN：Len：数据域字节长度，该值将直接使用在指令中，取值范围1-255
		IN：Data：数据域内容，可以是符合变量（如：“[VAR10]”）或常量名称（如：“[CON10]”）的字符串
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		注意：
		该函数并不会对数据域部分做任何样式调整
		**************************************/
	virtual string Update_Record(string P1, string P2, int Len, string Data, bool RefreshFlag = true);
		/**************************************
		功能：修改记录
		参数：（该方法将会自动获取所需配置参数）
		IN：MF：根目录，可以取值为"MF"、文件标志符（如"3F00"）或保留为空""，当为空时将默认为"MF"
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）、文件标志符（如"DDF1"、"DDF2"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：EF：基本文件，只能取值为文件标识符（如"EF05"、"EF06"等），该值不允许为空
		IN：ReaderNo：记录号，表示在指定文件中的记录序号，如果指定文件为循环文件，该值将会直接被忽略
		IN：InitFlag：数据域初始化标志，当该值为true时将会使用初始值（"00"或"FF"）对记录内容进行填充，否则将使用配置文件中的内容
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		注意：
		将固定构建写指定记录号数据的指令，P1固定为记录号，P2固定为0x04；
		对于循环文件记录，将忽略RecordNo指定的记录号，直接添加记录；
		当参数 InitFlag 为true时，将会根据记录的数据类型来进行初始值填充，如an型数据将使用00进行填充，cn型数据将会使用FF来进行填充；
		对于b型数据，都将当作二进制串处理（b型数据还有整数的含义）
		**************************************/
	virtual string Update_Record(string MF, string DDF, string ADF, string EF, int RecordNo, bool InitFlag = false, bool RefreshFlag = true);
		/**************************************
		功能：修改二进制
		参数：
		IN：Offset：需修改位置的首字节距文件首字节的偏移量，取值范围0-32767
		IN：Len：指定指令数据域的长度，该值将直接使用在指令中，取值范围0-255
		IN：Data：数据域内容，可以是符合变量（如：“[VAR10]”）或常量名称（如：“[CON10]”）的字符串
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		**************************************/
	virtual string Update_Binary(int Offset, int Len, string Data, bool RefreshFlag = true);
		/**************************************
		功能：创建内部文件
		参数：（该方法将会自动获取所需配置参数）
		IN：FType：所创建内部文件的类型，仅可取值为"SF"、"FCI"、"DIR"、"TF"、"ATR"
		IN：DataLen：文件总数据长度（实际空间），由最多8个字符组成的十六进制串组成
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		注意：
		SF：安全文件（密钥文件），读禁止，写受当前目录主控控制
		FCI：控制信息文件，读禁止，写受当前目录主控控制
		DIR：目录文件，读自由，写受当前目录主控控制
		TF：内部交易文件，【读禁止？】，写受DSK控制
		ATR：复位应答文件（暂时只在华大COS内见到），读禁止，写受当前目录主控控制
		**************************************/
	virtual string Create_Internal_EF(string FType, string DataLen, bool RefreshFlag = true) = 0;
		/**************************************
		功能：创建文件
		参数：（该方法将会自动获取所需配置参数）
		IN：MF：根目录，可以取值为"MF"、文件标志符（如"3F00"）或保留为空""，当为空时将默认为"MF"
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：EF：基本文件，可以取值为文件标识符（如"EF05"、"EF06"等）或保留位空""，当为空时将表示并非创建基本文件
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		描述：
		MF、DDF、ADF和EF四个入参，将根据最后一个非空的参数来确定将构建的指令是创建哪一个目录或文件；
		如入参（"MF", "SSSE", "", "EF05"）将表示创建SSSE下的EF05，入参（"MF", "SSSE", "", ""）将表示创建SSSE；
		注意：DDF目录不允许使用FID
		**************************************/
	virtual string Create_File(string MF = "", string DDF = "", string ADF = "", string EF = "", bool RefreshFlag = true) = 0;
		/**************************************
		功能：删除文件
		参数：
		IN：WorkFlag：工作标志，1-删除文件内容及目录空间；2-仅删除文件内容；其他-默认为1
		IN：FType：文件类型：只能取值为"MF"、"DDF"、"ADF"、"EF"，在某些COS中该值并非是必须值，此时可传入空串""
		IN：FID：需删除文件的FID，必须由4位字符组成，在某些COS中该值并非是必须值，此时可传入空串""
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		注意：
		该方法有可能会构建两条指令（如华大COS，删除文件内容及目录空间分开了两条指令），此时的返回串中将自动添加换行符
		**************************************/
	virtual string Delete_File(int WorkFlag, string FType = "", string FID = "", bool RefreshFlag = true) = 0;
	virtual string Delete_File(string MF, string DDF, string ADF, string EF, bool RefreshFlag = true) = 0;
		/**************************************
		功能：认证传输密钥
		参数：
		IN：Len：指定指令数据域的长度，该值将直接使用在指令中，取值范围0-255
		IN：Data：数据域内容，可以是符合变量（如：“[VAR10]”）或常量名称（如：“[CON10]”）的字符串
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		**************************************/
	virtual string Verify_TranCode(int Len, string Data, bool RefreshFlag = true) = 0;
		/**************************************
		功能：预个人化结束【完整指令】
		参数：
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		**************************************/
	virtual string End_PreIssue(bool RefreshFlag = true) = 0;
		/**************************************
		功能：安装固定密钥（明文不带MAC）【完整指令】
		参数：（该方法将会自动获取所需配置参数）
		IN：MF：根目录，可以取值为"MF"、文件标志符（如"3F00"）或保留为空""，当为空时将默认为"MF"
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：KeyName：密钥简称，如"IRK"、"PUK"、"RKSSSE"等，如果是主控请传入"MK"
		IN：KeyVer：密钥版本，要求必须由两个字符组成
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		注意：
		MF、DDF和ADF三个入参，将根据最后一个非空的参数来确定将构建的指令是创建哪一个目录；
		如入参（"MF", "SSSE", "DF01"）将表示创建SSSE下的DF01，入参（"MF", "SSSE", ""将表示SSSE；
		注意：DDF目录不允许使用FID
		**************************************/
	virtual string Write_Key(string MF, string DDF, string ADF, string KeyName, string KeyVer, bool RefreshFlag = true) = 0;
		/**************************************
		功能：添加密钥【需自行拼接】
		指令：该方法仅构建指令头部及密钥头部，并不构建完整的指令，应使用 InstHead 及 InstData 取出指令数据
		参数：（该方法将会自动获取所需配置参数）
		IN：MF：根目录，可以取值为"MF"、文件标志符（如"3F00"）或保留为空""，当为空时将默认为"MF"
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：KeyName：密钥简称，如"IRK"、"PUK"、"RKSSSE"等，如果是主控请传入"MK"
		IN：KeyVer：需安装密钥的版本号，要求必须由两个字符组成
		IN：Encrypt：加密标志，当该值为true时表示使用密文方式安装密钥
		IN：Mac：MAC标志，当该值为true是表示使用带MAC方式安装密钥
		返回：
		true：执行成功
		false：发生错误，InstHead与InstData将保持为空，此时应继续往下执行以获取更多的错误信息
		注意：
		参数 Encrypt 与 Mac 仅决定了指令头部的构建，至于密钥的真正安装形式将有外部来处理。
		DDF目录不允许使用FID
		**************************************/
	virtual bool Write_Key(string MF, string DDF, string ADF, string KeyName, string KeyVer, bool Encrypt, bool Mac) = 0;
		/**************************************
		功能：添加FCI记录
		参数：（该方法将会自动获取所需配置参数）
		IN：RecordNo：记录号，指定了本次所添加FCI记录的记录号，该值必须大于等于1
		IN：MF：根目录，可以取值为"MF"、文件标志符（如"3F00"）或保留为空""，当为空时将默认为"MF"
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）、文件标志符（如"DDF1"、"DDF2"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		描述：该方法将根据指定路径目录文件的FID及AID来构建一条含指令头部的完整FCI记录
		**************************************/
	virtual string FCI_Record(int RecordNo, string MF, string DDF, string ADF, bool RefreshFlag = true) = 0;
		/**************************************
		功能：添加DIR记录
		参数：（该方法将会自动获取所需配置参数）
		IN：RecordNo：记录号，指定了本次所添加DIR记录的记录号，该值必须大于等于1
		IN：MF：根目录，可以取值为"MF"、文件标志符（如"3F00"）或保留为空""，当为空时将默认为"MF"
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）、文件标志符（如"DDF1"、"DDF2"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：Label：应用标签，可以是任意值，对卡片来说该值并无特定的要求，唯一的作用就是作为一个简介标签来说明来应用的用途，如“社保应用”、“金融应用”等
		IN：RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
		返回：
		输出构建后的指令，如发生错误则输出空串
		描述：该方法将根据指定路径目录文件的FID及AID来构建一条含指令头部的完整DIR记录
		**************************************/
	virtual string DIR_Record(int RecordNo, string MF, string DDF, string ADF, string Label, bool RefreshFlag = true);
	/************************************************************************/
	/*名    称:	Update_ATR
	/*功    能:	更新卡片ATR
	/*输入参数:	strATRHead：历史字节T8之前的数据，这些数据根据不同的芯片厂商设定不同的值
	/*			strCardSN: 卡序列号(由2字节城市代码+4字节流水号构成)
	/*			RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
	/*输出参数:	null
	/*返 回 值:	返回更新ATR的完整指令
	/************************************************************************/
	virtual string Update_ATR(string strATRHead, string strCardSN, bool RefreshFlag = true) = 0;
	/************************************************************************/
	/*名    称:	PIN_Certify
	/*功    能:	校验PIN
	/*输入参数:	RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中
	/*输出参数:	null
	/*返 回 值:	返回校验PIN的完整指令
	/************************************************************************/
	string PIN_Certify(bool RefreshFlag = true);


protected:
	bool ErrFlag;		//错误标识，当执行出错时，该值将会被置为true
	bool ErrCheckFlag;	//错误检查标志，当该值为true时，构建指令时将会检查参数，参数检查会消耗一定的执行时间，如确保参数无误，可将其关闭
	CInformation * Info;		//信息记录类，记录在执行过程中所发生的错误信息，在构造函数中将会把该指针指向Command类中的成员
	CParameter * Param;		//参数类，在构建某些指令时需自行获取参数信息，在构造函数中将会把该指针指向Command类中的成员
	char InstHead[100];	//指令头部，大多数的指令方法都将会只构建指令头部，数据域内容需根据实际情况作添加
	char InstData[600];	//指令数据域，某些指令需要构建一些额外的信息，如文件头、密钥头等
	stringstream serr;	//主要用来组合错误信息
	stringstream sstr;	//用来组合指令
	string Extends;		//扩展参数，用以传输当前接口之外的参数，仅作备用
	string Style_Separator;	//指令头部与数据域内容间添加空格，如“00A4020002 EF05”
	string Style_InstHead;	//指令头部每字节间添加空格，如“00 84 00 00 08”，注如果与STYLE_SEPARATOR一起使用，指令头部与数据域间将会变作两个空格，如“00 A4 02 00 02  EF05”
	string Style_InstData;	//在数据域内容中添加恰当的空格（各函数有差异），只有在传入的数据域内容中不含任何常量及变量信息时才生效
	string SF_SFI;	//安全文件（密钥文件），注意SFI是段文件标识符，只由两位字符组成
	string FCI_SFI;	//控制信息文件
	string DIR_SFI;	//目录文件
	string TF_SFI;	//内部交易文件
	string ATR_SFI;	//复位应答文件



		/**************************************
		功能：初始化密钥的后续安全状态指示序号
		参数：
		IN：KeyNameIgnore：指示着一系列不进行序号分配的密钥，在此指示器中的密钥所分配的序号将固定为 0 。没有分配序号的密钥理论上来说应属于非外部认证密钥。
		描述：仅在建卡时生效，向同一ADF下的密钥分配各不相同的序号ID，各COS将可以根据密钥的序号来组构后续安全级别
		注意：不同COS的后续安全状态的规则不一样，需要剔除不进行序号分配的密钥也会略有差异，如复旦COS需要把PIN排除在外
		指示器格式：
		以竖杆“|”分割不同密钥名称，最后一项也需以竖杆结束。如：“IRK|STK|”。
		在每一项中可以使用“[”和“]”进行修饰，共分四种情况：不带中括号“XXX”、含左半边“[XXX”、含右半边“XXX]”、双边“[XXX]”
		不带中括号“XXX”	：只要密钥名称中含有子串匹配 XXX ，就认为该密钥不进行序号分配
		含左半边“[XXX”	：需要密钥名称的左起部分必须与 XXX 匹配，才会认为该密钥不进行序号分配
		含右半边“XXX]”	：需要密钥名称的右端结束部分必须与 XXX 匹配，才会认为该密钥不进行序号分配
		双边“[XXX]”		：要求密钥名称必须与 XXX 完全匹配，才会认为该密钥不进行序号分配
		示例：
		“[IRK]|[STK|[DLK]|”：将可以对应以下密钥：IRK、DLK、STK、STKDF03、STKDF07、STKXXX
		“[RK|DF03]|TK|”：将对应所有RK开头的密钥（如：RKSSSE、RKDF01等）、所有DF03结尾的密钥（如：UK1DF03、STKDF03等）、所有含有TK子串的密钥（如：STK、STKDF07、DTK等）【此处仅作示例，实际上这几个密钥作为外部认证密钥不应被剔除】
		设计：
		执行该函数的初始化之后，在 class CParameter 中 GetKeyInfo 方法所取出的密钥信息 KEYDATAS 中，将会含有该序号信息 m_nSeq 。
		非零的序号值 m_nSeq 将各不相同，此时各COS只要根据该序号值按照各自的规则就可以组成在同一ADF下各密钥互不相同的后续安全状态。
		**************************************/
	virtual void Init_Security_Level(string KeyNameIgnore);//初始化密钥的后续安全状态
		/**************************************
		功能：解析EF文件的读写控制密钥
		参数：
		IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）、文件标志符（如"DDF1"、"DDF2"等）或保留为空""，当为空时将表示应用目录不存在
		IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
		IN：CtrlStr：EF文件的读写控制密钥，空串""及"00"表示自由；"FF"表示禁止；Key表示当前目录密钥；Key + Key表示上级目录密钥及当前目录密钥；Key | key表示上级目录密钥或当前目录密钥
		OUT：keyData1：输出控制密钥
		OUT：keyData2：如果CtrlStr的形式为 Key + Key 或 Key | Key ，该参数将会输出当前目录的控制密钥，否则该参数无效
		OUT：ErrMsg：输出错误信息，如“找不到XXX密钥”等
		返回：
		<0：执行失败
		1：权限自由，此时keyData1和keyData2无效
		2：权限禁止，此时keyData1和keyData2无效
		3：受上级目录的PIN控制，将会在keyData1中输出密钥，keyData2无效
		4：受当前目录的某一密钥控制，将会在keyData1中输出密钥，keyData2无效
		5：受上级及当前目录密钥逻辑“与”关系控制，将会在keyData1中输出上级目录密钥，在keyData2中输出当前目录密钥
		6：受上级及当前目录密钥逻辑“或”关系控制，将会在keyData1中输出上级目录密钥，在keyData2中输出当前目录密钥
		**************************************/
	int EF_Control(string DDF, string ADF, string CtrlStr, KEYDATAS &keyData1, KEYDATAS &keyData2, string &ErrMsg);
		/**************************************
		功能：重置状态及清空缓存
		描述：在指令方法执行前调用，清除指令缓冲区
		**************************************/
	void Initialization();//清除缓存记录，进行初始化
		/**************************************
		功能：设置错误标识
		描述：将错误标识置为true，并重设Stream的缓存
		**************************************/
	void Set_Error_Flag();//设置错误标识
		/**************************************
		功能：检查输入数据是否有误
		参数：
		IN：Data：带检查的输入数据
		IN：Len：输入数据需满足的字节长度。注意：该值可以为负值，此时表示只要求输入数据的字节长度小于或等于该值，当该值为0时表示不做长度检查
		OUT：ErrMsg：输出错误信息
		返回：
		true：检查通过并无错误
		false：发生错误
		描述：
		检查双引号外的数据是否符合CN格式，双引号内的数据将自动忽略
		注意：
		本方法并不会自动处理空格，请事先将需检测数据中的空格去除。
		**************************************/
	bool CheckData(const string &Data, int Len, string &ErrMsg);
		/**************************************
		功能：处理从配置中读取到的常量字串
		参数：
		INOUT：ConData：输入待处理的常量字串，输出处理后的子串，将形如“CON10”扩展为“[CON10]”
		返回：
		描述：
		将从配置中获取到不完整的常量名称，更变为带中括号完整的
		**************************************/
	void CON_Extend(string &ConData);
};









#endif //INSTRUCTION_H