//#####################################
//
//	class CScript
//
//	脚本类（通过参数及指令而组成一个个小块的脚本功能）,目前仅支持社保结构的脚本生成
//  最后修改日期：20151109 17:30
//#####################################

#ifndef SCRIPT_H
#define SCRIPT_H

#include "Information.h"
#include "Parameter.h"
#include "Instruction.h"
#include "Command.h"
#include "..\Common.h"


/*脚本公共变量说明的宏定义 0-29预留为基类的公共变量 30-40预留给MAC和密文等计算的临时变量*/
#define _KEY 0			//VAR0   保存密钥
#define _RECNO 1		//VAR1   记录号
#define _CARD_SN 2		//VAR2   卡片SN
#define _COSMANU 3		//VAR3	 COS类型
#define _TRANS_KEY 4	//VAR4	 认证传输密钥
#define _STOWAGE 5		//VAR5	 LOADKEY装载方式
#define _PKEYNO 6		//VAR6	 LOADKEY保护密钥ID
#define _KEYFSJS 7		//VAR7	 LOADKEY导出密钥分散级数
#define _PKEYFSJS 8		//VAR8	 LOADKEY保护密钥（次主密钥）分散级数
#define _KEYFSYZ 9		//VAR9	 LOADKEY导出密钥分散因子
#define _VAR10 10		//VAR10	 认证密钥时保存随机数
#define _VAR11 11		//VAR11	 认证密钥时保存过程密钥
#define _VAR12 12		//VAR12	 认证密钥时保存过程密钥
#define _PKEYFSYZ 13	//VAR13	 LOADKEY保护密钥（次主密钥）分散因子
#define _ATR 14			//VAR14  用于存储复位信息
#define _MAC 15			//VAR15  用于存储计算的mac值
#define _CARDID 16		//VAR16  用于存储个人识别码
#define _TEMP 17		//VAR17  用于存储临时变量


class CScript
{
public:
	CScript( int COS, CInformation *cInfo );
	virtual ~CScript();

	/************************************************************************/
	/*名    称:	IssueCardProcess
	/*功    能:	构建发卡脚本流程
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	false	成功	true	构建脚本过程发生错误
	/************************************************************************/
	virtual bool IssueCardProcess() = 0;
	/************************************************************************/
	/*名    称:	ExchangeDatas
	/*功    能:	交换数据,接收对话框的数据
	/*输入参数:	nCheckKeys:1为清卡  nCheckATR:1为更新ATR  strSearial:流水号  strTranKey:传输密钥  vecQCParam：清卡所需的参数
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void ExchangeDatas( int nCheckKeys, int nCheckATR, string strSearial, string strTranKey, vector<CLEARCARDPARAM> vecQCParam );

protected:
	/************************************************************************/
	/*名    称:	LineFeed
	/*功    能:	脚本中添加换行
	/*输入参数:	nLineNum: 表示换行数
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void LineFeed( int nLineNum );
	/************************************************************************/
	/*名    称:	LvOne_Annotations
	/*功    能:	一级注释,用于一般注释,注释方式如 ;------注释内容
	/*输入参数:	strDatas: 注释内容	
	/*			RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中，该参数不填写时候默认为true
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	string LvOne_Annotations( string strDatas, bool RefreshFlag = true );
	/************************************************************************/
	/*名    称:	LvTwo_Annotations
	/*功    能:	二级注释,用于分割注释,注释方式如 ;==============注释内容==============
	/*输入参数:	strDatas: 注释内容	
	/*			RefreshFlag：刷新标志，当该值为true时，所构建的指令将会自动添加至生成的脚本缓存中，该参数不填写时候默认为true
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	string LvTwo_Annotations( string strDatas, bool RefreshFlag = true  );
	/************************************************************************/
	/*名    称:	GetAndSetParama
	/*功    能:	设置脚本参数,包括获取参数类的数据、设置连接加密机、设置装载密钥参数等脚本通用数据
	/*输入参数:	strCOS：用于设置用加密机装载密钥时候的COS厂商参数 0－华大，1－德生，3－华虹，4－同方，5－大唐 （可扩充）'暂不理 6: 天津卡, 7 华虹
	/*			且当为华虹、同方芯片时配置中如果装载密钥方式是密文方式的话会更改为明文方式，因为华虹、同方仅支持明文方式装载密钥
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void GetAndSetParama( string strCOS );
	/************************************************************************/
	/*名    称:	ScriptModeStatement
	/*功    能:	脚本作者和修改日期等声明
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void ScriptModeStatement();
	/************************************************************************/
	/*名    称:	CON_Statement
	/*功    能:	脚本常量说明
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void CON_Statement();
	/************************************************************************/
	/*名    称:	VAR_Statement
	/*功    能:	脚本变量说明
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void VAR_Statement();
	/************************************************************************/
	/*名    称:	PersonnalVAR_Statement
	/*功    能:	个人化脚本变量说明(子类个人化的变量从VAR41往后开始取,0-29预留为基类的公共变量 30-40预留给MAC和密文等计算的临时变量),
	/*			若继承类需要用别的变量则需要在继承类中宏定义变量并重写该接口实现说明变量
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	virtual void PersonnalVAR_Statement();
	/************************************************************************/
	/*名    称:	ClearCarad
	/*功    能:	清卡（清除SSSE、PSE、MF）
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void ClearCarad();
	/**************************************
	功能：初始化EF文件
	前提：请先创建并选中EF文件以后
	参数：
	IN：DDF：应用目录，可以取值为应用环境简称（如"SSSE"、"PSE"等）或保留为空""，当为空时将表示应用目录不存在（MF目录下），因为要判断个人识别码计算所以不能用FID
	IN：ADF：文件目录，可以取值为文件标识符（如"DF01"、"DF02"等）或保留为空""，当为空时将表示文件目录不存在
	IN：EF：基本文件，只能取值为文件标识符（如"EF05"、"EF06"等），该值不允许为空
	返回：
	true：执行成功；false：执行失败。
	描述：
	可以初始化记录文件及透明文件，循环文件将不做任何处理，内部文件将返回错误
	**************************************/
	bool InitFile(string DDF, string ADF, string EF);
	/************************************************************************/
	/*名    称:	Dir_UpdateRecord
	/*功    能:	获取目录文件的记录,程序会获取MF下直属的所有DDF、ADF的相关记录信息脚本数据,并返回所有记录的长度(只有在MF下才需要创建目录文件并添加记录)
	/*输入参数:	null
	/*输出参数:	strsInsts：添加的所有记录的脚本数据（获取MF下的所有DDF、ADF的记录）,若返回值为00表示没有记录可添加(获取脚本数据)
	/*返 回 值:	返回目录文件所有记录的总长度（单位字节）(用十六进制数表示)
	/************************************************************************/
	string Dir_Records( stringstream &strsInsts );
	/************************************************************************/
	/*名    称:	FCI_AppendRecord
	/*功    能:	获取文件控制信息的相关记录,并返回所有记录的长度(只有在MF和DDF下才需要创建FCI文件并添加记录)
	/*输入参数:	strDDF: 应用目录,可以取值为应用环境简称（如"SSSE"、"PSE"等）或FID文件标志符（如"DDF1"、"DDF2"等）或保留为空"" (不区分大小写)	
	/*输出参数:	strsInsts：添加的所有记录的脚本数据(获取脚本数据)
	/*返 回 值:	返回FCI文件所有记录的总长度（单位字节)(用十六进制数表示),若返回值为00表示没有记录可添加
	/*注    意：若需要添加MF\DDF下的所有FCI记录时,调用方式为FCI_AppendRecord( "DDF", strsScrDatas ),此时会获得添加MF、该DDF、该DDF下所有ADF的FIC记录
	/*			若需要添加MF下的所有FCI记录时,调用方式为FCI_AppendRecord( "", strsScrDatas ),此时会获得添加MF、MF下所有DDF和ADF的FIC记录
	/************************************************************************/
	string FCI_Records( string strDDF, stringstream &strsInsts );
	/************************************************************************/
	/*名    称:	LoadKeys 
	/*功    能:	获取装载密钥的脚本数据(包括主控密钥的其他密钥的脚本数据)，只有在MF、DDF、ADF下才需要装载密钥，SSSE下还额外装载PIN
	/*输入参数:	strDDF: 应用目录,可以取值为应用环境简称（如"SSSE"、"PSE"等,即DDFName）或保留为空"" 
	/*			strADF：文件目录,可以取值为FID文件标识符（如"DF01"、"DF02"等）或保留为空"" 
	/*输出参数:	strsInsts：添加的所有密钥的脚本数据(获取脚本数据)
	/*返 回 值:	返回装载的密钥数据的总长度（单位字节)(用十六进制数表示)(因为配置里的主控密钥不能为空所以至少存在装载主控密钥的指令)
	/*注    意：(基类中的实现过程以大唐芯片的装载密钥流程为准,如有区别的请在继承类中重写该接口)
	/*			若需要装载MF下的所有密钥时,调用方式为LoadKeys( "", "", strsScrDatas )
	/*			若需要装载MF\DDF下的所有密钥时,调用方式为LoadKeys( "DDF", "", strsScrDatas )
	/*			若需要装载MF\ADF下的所有密钥时,调用方式为LoadKeys( "", "ADF", strsScrDatas )
	/*			若需要装载MF\DDF\ADF下的所有密钥时,调用方式为LoadKeys( "DDF", "ADF", strsScrDatas )
	/************************************************************************/
	virtual string LoadKeys( string strDDF, string strADF, stringstream &strsInsts );
	/************************************************************************/
	/*名    称:	GetCardID
	/*功    能:	计算个人识别码(自动添加计算过程的脚本数据)
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	void GetCardID();
	/************************************************************************/
	/*名    称:	CreateMF
	/*功    能:	建MF,MF是一定存在的,如果不存在的话,检测读取XML配置的时候就报错了,不会生成建卡脚本
	/*			操作流程包括：认证传输密钥、建MF、建安全文件并添加记录(装载密钥)、建目录文件并选择文件添加记录、建FCI文件并添加记录、外部认证MF的主控(如果流程有区别的需要在继承类重写该接口)
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	virtual void CreateMF();
	/************************************************************************/
	/*名    称:	CreateDDF
	/*功    能:	建MF下的DDF文件(除了DDF0外)
	/*			操作流程包括：选择MF文件、建DDF、建安全文件并添加记录(装载密钥)、建FCI文件并添加记录、外部认证DDF的主控(如果流程有区别的需要在继承类重写该接口)
	/*输入参数:	strDDF: 应用目录,可以取值为应用环境简称（如"SSSE"、"PSE"等,即DDFName）（若该值为空或者为DDF0的话不会构建该DDF）
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	virtual void CreateDDF( string strDDF );
	/************************************************************************/
	/*名    称:	CreateADFS
	/*功    能:	建立当前MF/DDF下直属的所有ADF文件(除DF00以外)
	/*输入参数:	strDDF: 应用目录,可以取值为应用环境简称（如"SSSE"、"PSE"等）或FID文件标志符（如"DDF1"、"DDF2"等）或保留为空"" (不区分大小写) 
	/*输出参数:	null
	/*返 回 值:	null
	/*注    意：脚本流程分为以下几种情况(如果流程有区别的需要在继承类重写该接口)
	/*			如果参数strDDF为空的话，则会直接建MF下的直属ADF文件(前提是MF下有ADF文件存在),操作流程为: 选择MF文件、建立MF下直属的所有ADF文件
	/*			如果参数strDDF不为空的话，则会直接建DDF下的直属ADF文件,操作流程为: 选择DDF文件、建立当前DDF下直属的所有ADF文件
	/************************************************************************/
	virtual void CreateADFS( string strDDF = "" );
	/************************************************************************/
	/*名    称:	CreateEFS
	/*功    能:	建MF/DDF/ADF下直属的所有EF文件并写记录
	/*输入参数:	strDDF: 应用目录,可以取值为应用环境简称（如"SSSE"、"PSE"等,即DDFName）或保留为空"" (不区分大小写)
	/*			strADF：文件目录,可以取值为FID文件标识符（如"DF01"、"DF02"等）或保留为空"" (不区分大小写)	
	/*输出参数:	null
	/*返 回 值:	null
	/*注    意：脚本流程分为以下几种情况(如果流程有区别的需要在继承类重写该接口)
	/*			若需要建MF下的所有EF文件时,调用方式为CeateEF( "", "" )或者CeateEF(),操作流程为: 选择MF文件、建EF文件、调用接口写文件记录
	/*			若需要建MF/DDF下的所有EF文件时,调用方式为CeateEF( "DDF", "" )或者CeateEF( "DDF" ),操作流程为: 选择DDF文件、建EF文件、调用接口写文件记录
	/*			若需要建MF/ADF下的所有EF文件时,调用方式为CeateEF( "", "ADF" ),操作流程为: 选择ADF文件、建安全文件并添加记录、外部认证ADF的主控、建EF文件、调用接口写文件记录
	/*			若需要建MF/DDF/ADF下的所有EF文件时,调用方式为CeateEF( "DDF", "ADF" ),操作流程为: 选择ADF文件、建安全文件并添加记录、外部认证ADF的主控、建EF文件、调用接口写文件记录
	/************************************************************************/
	virtual void CreateEFS( string strDDF = "", string strADF = "" );
	/************************************************************************/
	/*名    称:	End_AllPreIssue
	/*功    能:	预个人化结束所有的MF、DDF、ADF文件(除了DDF0和DF00外)，需要在脚本最后预个人化结束的时候再调用该接口
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/*注    意：脚本流程为:(如果流程有区别的需要在继承类重写该接口)
	/*			选择文件、预个人化结束(遍历卡结构从一级目录往下级目录依次预个人化结束)
	/************************************************************************/
	virtual void End_AllPreIssue();
	/************************************************************************/
	/*名    称:	UpdateATR
	/*功    能:	更新卡片ATR，该接口在清卡后、建MF前执行才会有效，流程包括：认证传输密钥，更新ATR； 
	/*			因不同厂商芯片的ATR历史字节有区别，固数据在继承类中重写接口去设定更新ATR的参数
	/*输入参数:	null
	/*输出参数:	null
	/*返 回 值:	null
	/************************************************************************/
	virtual void UpdateATR()=0;

	CInstruction *cInst;
	CInformation *const cInfo;
	CParameter *cParameter;
	CCommand *cCmd;
	int m_nCheckKeys,m_nCheckATR;//分别为1时表示进行清卡和更新ATR
	string m_strSearial;//流水号 更新ATR时用
	string m_strTranKey;//传输密钥值
	vector<CLEARCARDPARAM> m_vecCLCParam;//清卡所需的参数
	bool m_bRefreshFlag;//刷新标志，true:所构建的指令将会自动添加至生成的脚本缓存中
	stringstream m_sstrTemp;//临时存储变量
	string m_strTemp;//临时存储变量
	vector<S_DDFINFO> m_vecMFStruct;//存储获取的卡片结构
	S_MFINFO m_struMFInfo;//存储MF信息
	LOADKEYINFO m_struLoadKeyInfo;//存储装载密钥相关信息

private:
	string m_strLoadKeyMode;//装载密钥的方式 0：密文	1：明文	10：密文更新	11：明文更新
};

#endif //SCRIPT_H